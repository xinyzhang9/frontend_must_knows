// wrong output 6,6,6,6,6

// for(var i = 1; i <=5; i++){
// 	setTimeout(function timer(){
// 		console.log(i);
// 	},i*1000);
// }

// correct output 1,2,3,4,5
for(var i = 1; i <=5; i++){
	(function(i){setTimeout(function timer(){
		console.log(i);
	},i*1000)})(i)
}


// 如果我们直接这样写，根据setTimeout定义的操作在函数调用栈清空之后才会执行的特点，for循环里定义了5个setTimeout操作。而当这些操作开始执行时，for循环的i值，已经先一步变成了6。因此输出结果总为6。而我们想要让输出结果依次执行，我们就必须借助闭包的特性，每次循环时，将i值保存在一个闭包中，当setTimeout中定义的操作执行时，则访问对应闭包保存的i值即可。

// 而我们知道在函数中闭包判定的准则，即执行时是否在内部定义的函数中访问了上层作用域的变量。因此我们需要包裹一层自执行函数为闭包的形成提供条件。

// 因此，我们只需要2个操作就可以完成题目需求，一是使用自执行函数提供闭包条件，二是传入i值并保存在闭包中。